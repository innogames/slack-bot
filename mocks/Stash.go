// Code generated by mockery v1.0.0
package mocks

import http "net/http"
import mock "github.com/stretchr/testify/mock"
import stash "github.com/xoom/stash"

// Stash is an autogenerated mock type for the Stash type
type Stash struct {
	mock.Mock
}

// ApprovePullRequest provides a mock function with given fields: projectKey, repositorySlug, pullRequestID, pullRequestVersion
func (_m *Stash) ApprovePullRequest(projectKey string, repositorySlug string, pullRequestID int, pullRequestVersion int) error {
	ret := _m.Called(projectKey, repositorySlug, pullRequestID, pullRequestVersion)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, int, int) error); ok {
		r0 = rf(projectKey, repositorySlug, pullRequestID, pullRequestVersion)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateBranchRestriction provides a mock function with given fields: projectKey, repositorySlug, branch, user
func (_m *Stash) CreateBranchRestriction(projectKey string, repositorySlug string, branch string, user string) (stash.BranchRestriction, error) {
	ret := _m.Called(projectKey, repositorySlug, branch, user)

	var r0 stash.BranchRestriction
	if rf, ok := ret.Get(0).(func(string, string, string, string) stash.BranchRestriction); ok {
		r0 = rf(projectKey, repositorySlug, branch, user)
	} else {
		r0 = ret.Get(0).(stash.BranchRestriction)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string) error); ok {
		r1 = rf(projectKey, repositorySlug, branch, user)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateComment provides a mock function with given fields: projectKey, repositorySlug, pullRequest, text
func (_m *Stash) CreateComment(projectKey string, repositorySlug string, pullRequest string, text string) (stash.Comment, error) {
	ret := _m.Called(projectKey, repositorySlug, pullRequest, text)

	var r0 stash.Comment
	if rf, ok := ret.Get(0).(func(string, string, string, string) stash.Comment); ok {
		r0 = rf(projectKey, repositorySlug, pullRequest, text)
	} else {
		r0 = ret.Get(0).(stash.Comment)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string) error); ok {
		r1 = rf(projectKey, repositorySlug, pullRequest, text)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePullRequest provides a mock function with given fields: projectKey, repositorySlug, title, description, fromRef, toRef, reviewers
func (_m *Stash) CreatePullRequest(projectKey string, repositorySlug string, title string, description string, fromRef string, toRef string, reviewers []string) (stash.PullRequest, error) {
	ret := _m.Called(projectKey, repositorySlug, title, description, fromRef, toRef, reviewers)

	var r0 stash.PullRequest
	if rf, ok := ret.Get(0).(func(string, string, string, string, string, string, []string) stash.PullRequest); ok {
		r0 = rf(projectKey, repositorySlug, title, description, fromRef, toRef, reviewers)
	} else {
		r0 = ret.Get(0).(stash.PullRequest)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string, string, string, []string) error); ok {
		r1 = rf(projectKey, repositorySlug, title, description, fromRef, toRef, reviewers)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateRepository provides a mock function with given fields: projectKey, slug
func (_m *Stash) CreateRepository(projectKey string, slug string) (stash.Repository, error) {
	ret := _m.Called(projectKey, slug)

	var r0 stash.Repository
	if rf, ok := ret.Get(0).(func(string, string) stash.Repository); ok {
		r0 = rf(projectKey, slug)
	} else {
		r0 = ret.Get(0).(stash.Repository)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(projectKey, slug)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeclinePullRequest provides a mock function with given fields: projectKey, repositorySlug, pullRequestID, pullRequestVersion
func (_m *Stash) DeclinePullRequest(projectKey string, repositorySlug string, pullRequestID int, pullRequestVersion int) error {
	ret := _m.Called(projectKey, repositorySlug, pullRequestID, pullRequestVersion)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, int, int) error); ok {
		r0 = rf(projectKey, repositorySlug, pullRequestID, pullRequestVersion)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteBranch provides a mock function with given fields: projectKey, repositorySlug, branchName
func (_m *Stash) DeleteBranch(projectKey string, repositorySlug string, branchName string) error {
	ret := _m.Called(projectKey, repositorySlug, branchName)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, string) error); ok {
		r0 = rf(projectKey, repositorySlug, branchName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteBranchRestriction provides a mock function with given fields: projectKey, repositorySlug, id
func (_m *Stash) DeleteBranchRestriction(projectKey string, repositorySlug string, id int) error {
	ret := _m.Called(projectKey, repositorySlug, id)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, int) error); ok {
		r0 = rf(projectKey, repositorySlug, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetBranchRestrictions provides a mock function with given fields: projectKey, repositorySlug
func (_m *Stash) GetBranchRestrictions(projectKey string, repositorySlug string) (stash.BranchRestrictions, error) {
	ret := _m.Called(projectKey, repositorySlug)

	var r0 stash.BranchRestrictions
	if rf, ok := ret.Get(0).(func(string, string) stash.BranchRestrictions); ok {
		r0 = rf(projectKey, repositorySlug)
	} else {
		r0 = ret.Get(0).(stash.BranchRestrictions)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(projectKey, repositorySlug)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBranches provides a mock function with given fields: projectKey, repositorySlug
func (_m *Stash) GetBranches(projectKey string, repositorySlug string) (map[string]stash.Branch, error) {
	ret := _m.Called(projectKey, repositorySlug)

	var r0 map[string]stash.Branch
	if rf, ok := ret.Get(0).(func(string, string) map[string]stash.Branch); ok {
		r0 = rf(projectKey, repositorySlug)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]stash.Branch)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(projectKey, repositorySlug)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCommit provides a mock function with given fields: projectKey, repositorySlug, commitHash
func (_m *Stash) GetCommit(projectKey string, repositorySlug string, commitHash string) (stash.Commit, error) {
	ret := _m.Called(projectKey, repositorySlug, commitHash)

	var r0 stash.Commit
	if rf, ok := ret.Get(0).(func(string, string, string) stash.Commit); ok {
		r0 = rf(projectKey, repositorySlug, commitHash)
	} else {
		r0 = ret.Get(0).(stash.Commit)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(projectKey, repositorySlug, commitHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCommits provides a mock function with given fields: projectKey, repositorySlug, commitSinceHash, commitUntilHash
func (_m *Stash) GetCommits(projectKey string, repositorySlug string, commitSinceHash string, commitUntilHash string) (stash.Commits, error) {
	ret := _m.Called(projectKey, repositorySlug, commitSinceHash, commitUntilHash)

	var r0 stash.Commits
	if rf, ok := ret.Get(0).(func(string, string, string, string) stash.Commits); ok {
		r0 = rf(projectKey, repositorySlug, commitSinceHash, commitUntilHash)
	} else {
		r0 = ret.Get(0).(stash.Commits)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string) error); ok {
		r1 = rf(projectKey, repositorySlug, commitSinceHash, commitUntilHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPullRequest provides a mock function with given fields: projectKey, repositorySlug, identifier
func (_m *Stash) GetPullRequest(projectKey string, repositorySlug string, identifier string) (stash.PullRequest, error) {
	ret := _m.Called(projectKey, repositorySlug, identifier)

	var r0 stash.PullRequest
	if rf, ok := ret.Get(0).(func(string, string, string) stash.PullRequest); ok {
		r0 = rf(projectKey, repositorySlug, identifier)
	} else {
		r0 = ret.Get(0).(stash.PullRequest)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(projectKey, repositorySlug, identifier)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPullRequests provides a mock function with given fields: projectKey, repositorySlug, state
func (_m *Stash) GetPullRequests(projectKey string, repositorySlug string, state string) ([]stash.PullRequest, error) {
	ret := _m.Called(projectKey, repositorySlug, state)

	var r0 []stash.PullRequest
	if rf, ok := ret.Get(0).(func(string, string, string) []stash.PullRequest); ok {
		r0 = rf(projectKey, repositorySlug, state)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]stash.PullRequest)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string) error); ok {
		r1 = rf(projectKey, repositorySlug, state)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRawFile provides a mock function with given fields: projectKey, repositorySlug, branch, filePath
func (_m *Stash) GetRawFile(projectKey string, repositorySlug string, branch string, filePath string) ([]byte, error) {
	ret := _m.Called(projectKey, repositorySlug, branch, filePath)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(string, string, string, string) []byte); ok {
		r0 = rf(projectKey, repositorySlug, branch, filePath)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string) error); ok {
		r1 = rf(projectKey, repositorySlug, branch, filePath)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRepositories provides a mock function with given fields:
func (_m *Stash) GetRepositories() (map[int]stash.Repository, error) {
	ret := _m.Called()

	var r0 map[int]stash.Repository
	if rf, ok := ret.Get(0).(func() map[int]stash.Repository); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[int]stash.Repository)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRepository provides a mock function with given fields: projectKey, repositorySlug
func (_m *Stash) GetRepository(projectKey string, repositorySlug string) (stash.Repository, error) {
	ret := _m.Called(projectKey, repositorySlug)

	var r0 stash.Repository
	if rf, ok := ret.Get(0).(func(string, string) stash.Repository); ok {
		r0 = rf(projectKey, repositorySlug)
	} else {
		r0 = ret.Get(0).(stash.Repository)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(projectKey, repositorySlug)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTags provides a mock function with given fields: projectKey, repositorySlug
func (_m *Stash) GetTags(projectKey string, repositorySlug string) (map[string]stash.Tag, error) {
	ret := _m.Called(projectKey, repositorySlug)

	var r0 map[string]stash.Tag
	if rf, ok := ret.Get(0).(func(string, string) map[string]stash.Tag); ok {
		r0 = rf(projectKey, repositorySlug)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]stash.Tag)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(projectKey, repositorySlug)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MergePullRequest provides a mock function with given fields: projectKey, repositorySlug, pullRequestID, pullRequestVersion
func (_m *Stash) MergePullRequest(projectKey string, repositorySlug string, pullRequestID int, pullRequestVersion int) error {
	ret := _m.Called(projectKey, repositorySlug, pullRequestID, pullRequestVersion)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, int, int) error); ok {
		r0 = rf(projectKey, repositorySlug, pullRequestID, pullRequestVersion)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetHTTPClient provides a mock function with given fields: httpClient
func (_m *Stash) SetHTTPClient(httpClient *http.Client) {
	_m.Called(httpClient)
}

// UpdatePullRequest provides a mock function with given fields: projectKey, repositorySlug, identifier, version, title, description, toRef, reviewers
func (_m *Stash) UpdatePullRequest(projectKey string, repositorySlug string, identifier string, version int, title string, description string, toRef string, reviewers []string) (stash.PullRequest, error) {
	ret := _m.Called(projectKey, repositorySlug, identifier, version, title, description, toRef, reviewers)

	var r0 stash.PullRequest
	if rf, ok := ret.Get(0).(func(string, string, string, int, string, string, string, []string) stash.PullRequest); ok {
		r0 = rf(projectKey, repositorySlug, identifier, version, title, description, toRef, reviewers)
	} else {
		r0 = ret.Get(0).(stash.PullRequest)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, int, string, string, string, []string) error); ok {
		r1 = rf(projectKey, repositorySlug, identifier, version, title, description, toRef, reviewers)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
